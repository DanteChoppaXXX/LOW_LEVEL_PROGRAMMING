
# Buffer Overflow Trace Summary – 32-bit Stack Walk

## Program
```c
char buffer[10];
```

## Goal
Understand how function calls and stack behavior relate to buffer overflow.

---

## Steps Taken

### 1. Compiled With Exploit-Friendly Flags
```bash
gcc -g -fno-stack-protector -z execstack -no-pie -m32 -o getuser getuser.c
```

### 2. Set Breakpoint Inside Function
```gdb
gdb ./getuser
break get_username
run
```

### 3. Examined Stack
- Inspected registers:
  ```gdb
  info registers
  ```
- Dumped stack:
  ```gdb
  x/32x $esp
  ```

### 4. Identified Buffer
- `buffer` was found at:
  ```
  ebp - 0x0C
  ```
  Meaning: 12 bytes below the base pointer.

### 5. Overflow Discovered
- Input: `AAAAAAAAAAAAAAAAAAAAAAAAAA` (26 `A`s)
- Result: return address overwritten at byte **26**
- Stack layout:

  ```
  [ebp + 4]    ← Return Address (overwritten at byte 26)
  [ebp + 0]    ← Saved EBP
  [ebp - 0x0C] ← buffer[10]
  ```

---

## Conclusion
A **26-byte input overflows buffer and overwrites return address** — buffer overflow confirmed. You now know:
- Where buffer lives
- Where the return address is
- How stack frames are created and manipulated
